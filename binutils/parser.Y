// -*- mode: c++; -*-

%{

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <inttypes.h>
#include <string>
#include <iostream>
#include "tokenizer.H"
#include "parse_actions.H"

extern int yylex( void );
extern void yyerror( const std::string e );
extern int yylineno; // autogenerated by flex

#define YYDEBUG 1
//#define YYSTACKSIZE 50000

using namespace std;

%}

%union
{
    std::string * name;
    std::string * bytes;
    uint16_t value;
    struct expr * expression;
}

%token ORG EQU COMMA LP RP PLUS ASCII ASCIIZ BYTE WORD SPACE NL GLOBAL
%token <bytes> STRING
%token <value> REG
%token <value> CONST
%token <name> LABEL
%token <name> SYMBOL

%token OR       ORI
%token AND      ANDI
%token XOR      XORI
%token ADD ADDB ADDI ADDBI
%token SUB SUBB SUBI SUBBI
%token ROL ROLB ROLI ROLBI
%token CMP CMPB CMPI CMPBI
%token NEG NEGB
%token LI  LIB
%token LD  LDB              LDU LDBU
%token ST  STB              STU STBU
%token IN OUT
%token BR BRL BA BEQ BNE BLT BGT BLE BGE JMP JMPL MR

%type <expression> EXPR EXPR_SERIES

%start ASSEMBLY_FILE

%%

ASSEMBLY_FILE
	: LINE
	| ASSEMBLY_FILE LINE
	;

LINE
	: NL
        | SYMBOL EQU CONST NL
        { add_symbol($1, $3); }
	| LABEL GLOBAL NL
        { add_label($1, true); }
	| LABEL NL
        { add_label($1, false); }
	| ORG CONST NL
        { add_org($2); }
	| INSTRUCTION NL
        | ASCII STRING NL
        { add_string($2,false); }
        | ASCIIZ STRING NL
        { add_string($2,true); }
        | BYTE EXPR_SERIES NL
        { add_bytes( $2 ); }
        | WORD EXPR_SERIES NL
        { add_words( $2 ); }
	| SPACE EXPR NL
        { add_space( $2 ); }
	;

INSTRUCTION
	: OR    REG COMMA REG
        { emit_2r(0x0000,$2,$4); }
	| ORI   REG COMMA EXPR
        { emit_2ri(0x0800,$2,$4); }
	| MR    REG COMMA REG
        { emit_2r(0x0400,$2,$4); }
	| AND   REG COMMA REG
        { emit_2r(0x1000,$2,$4); }
	| ANDI  REG COMMA EXPR
        { emit_2ri(0x1800,$2,$4); }
	| XOR   REG COMMA REG
        { emit_2r(0x2000,$2,$4); }
	| XORI  REG COMMA EXPR
        { emit_2ri(0x2800,$2,$4); }
	| ADD   REG COMMA REG
        { emit_2r(0x3000,$2,$4); }
	| ADDB  REG COMMA REG
        { emit_2r(0x3400,$2,$4); }
	| ADDI  REG COMMA EXPR
        { emit_2ri(0x3800,$2,$4); }
	| ADDBI REG COMMA EXPR
        { emit_2ri(0x3c00,$2,$4); }
	| SUB   REG COMMA REG
        { emit_2r(0x4000,$2,$4); }
	| SUBB  REG COMMA REG
        { emit_2r(0x4400,$2,$4); }
	| SUBI  REG COMMA EXPR
        { emit_2ri(0x4800,$2,$4); }
	| SUBBI REG COMMA EXPR
        { emit_2ri(0x4c00,$2,$4); }
	| ROL   REG COMMA REG
        { emit_2r(0x5000,$2,$4); }
	| ROLB  REG COMMA REG
        { emit_2r(0x5400,$2,$4); }
	| ROLI  REG COMMA EXPR
        { emit_2ri(0x5800,$2,$4); }
	| ROLBI REG COMMA EXPR
        { emit_2ri(0x5c00,$2,$4); }
	| CMP   REG COMMA REG
        { emit_2r(0x6000,$2,$4); }
	| CMPB  REG COMMA REG
        { emit_2r(0x6400,$2,$4); }
	| CMPI  REG COMMA EXPR
        { emit_2ri(0x6800,$2,$4); }
	| CMPBI REG COMMA EXPR
        { emit_2ri(0x6c00,$2,$4); }
	| NEG   REG 
        { emit_1r(0x7000,$2); }
	| NEGB  REG
        { emit_1r(0x7400,$2); }
	| LI    REG COMMA EXPR
        { emit_2ri(0x8800,$2,$4); }
	| LIB   REG COMMA EXPR
        { emit_2ri(0x8c00,$2,$4); }
	| LD    REG COMMA EXPR LP REG RP
        { emit_2ro(0x9800,$2,$4,$6); }
	| LDB   REG COMMA EXPR LP REG RP
        { emit_2ro(0x9c00,$2,$4,$6); }
	| LDU   REG COMMA EXPR LP REG RP
        { emit_2ro(0x9a00,$2,$4,$6); }
	| LDBU  REG COMMA EXPR LP REG RP
        { emit_2ro(0x9e00,$2,$4,$6); }
	| ST    REG COMMA EXPR LP REG RP
        { emit_2ro(0xa800,$2,$4,$6); }
	| STB   REG COMMA EXPR LP REG RP
        { emit_2ro(0xac00,$2,$4,$6); }
	| STU   REG COMMA EXPR LP REG RP
        { emit_2ro(0xaa00,$2,$4,$6); }
	| STBU  REG COMMA EXPR LP REG RP
        { emit_2ro(0xae00,$2,$4,$6); }
	| IN    REG COMMA EXPR LP REG RP
        { emit_2ro(0xb800,$2,$4,$6); }
	| OUT   REG COMMA EXPR LP REG RP
        { emit_2ro(0xc800,$2,$4,$6); }
	| BR    REG
        { emit_1r(0xd000,$2); }
	| BRL   REG
        { emit_1r(0xd400,$2); }
        | BA    EXPR
        { emit_rel(0xe800,$2); }
        | BEQ   EXPR
        { emit_rel(0xe801,$2); }
        | BNE   EXPR
        { emit_rel(0xe802,$2); }
        | BLT   EXPR
        { emit_rel(0xe803,$2); }
        | BGT   EXPR
        { emit_rel(0xe804,$2); }
        | BLE   EXPR
        { emit_rel(0xe805,$2); }
        | BGE   EXPR
        { emit_rel(0xe806,$2); }
	| JMP   EXPR
        { emit_abs(0xf800,$2); }
	| JMPL   REG COMMA EXPR
        { emit_2ri(0xfc00,$2,$4); }
	;

EXPR_SERIES
	: EXPR
        { $$ = $1; }
        | EXPR COMMA EXPR_SERIES
        { $$ = $1; $$->next = $3; }
        ;

EXPR
	: CONST
	{
            $$ = new expr;
            $$->name = NULL;
            $$->value = $1;
        }
	| SYMBOL
        {
            $$ = new expr;
            $$->name = $1;
            $$->value = 0;
        }
	| SYMBOL PLUS CONST
        {
            $$ = new expr;
            $$->name = $1;
            $$->value = $3;
        }
	| LP EXPR RP
        {
            $$ = $2;
        }
	;

%%

void
yyerror( const std::string e )
{
    fprintf(stderr, "error: %d: %s\n", yylineno, e.c_str());
    exit( 1 );
}

int yylex(void);

void 
print_tokenized_file(void)
{
    while (1)
    {
        int c = yylex();

	printf( "got token %d (%s) ", 
		c, c <= YYMAXTOKEN ? yyname[c] : "");

        if (c == REG) printf("reg %d", yylval.value);
        if (c == CONST) printf("const %d", yylval.value);
        if (c == LABEL) printf("label: '%s'", yylval.name->c_str());
        if (c == SYMBOL) printf("symbol: '%s'", yylval.name->c_str());

        printf("\n");

        if (c <= 0)
            break;
    }
}
